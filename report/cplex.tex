\chapter{Cplex}

CPLEX is a high-performance optimization software developed by IBM that specializes in solving mathematical programming problems, including linear programming, mixed-integer programming, and quadratic programming, among others. It is one of the most widely used commercial solvers for solving complex optimization problems in various industries and academic research.

CPLEX provides a comprehensive suite of algorithms and techniques to efficiently solve optimization problems of varying sizes and complexities. It employs state-of-the-art optimization algorithms, such as the primal-dual interior point method for linear programming and branch-and-bound algorithms for mixed-integer programming, to find high-quality solutions within reasonable timeframes. 

One of the key features of CPLEX is its ability to handle large-scale optimization problems efficiently. It incorporates advanced preprocessing techniques, presolve routines, and cutting-plane algorithms to reduce problem size and improve solution quality. Additionally, CPLEX offers parallel computing capabilities, leveraging multiple CPU cores and distributed computing environments to accelerate the solution process for large-scale problems.

Overall, CPLEX is a powerful optimization tool that enables users to model, solve, and analyze complex optimization problems across diverse domains, including operations research, logistics, supply chain management, finance, and engineering. Its robust performance, scalability, and versatility make it a valuable asset for researchers, practitioners, and organizations seeking to optimize their decision-making processes.

CPLEX is useful for solving the TSP due to its efficient solver, scalability for large instances, support for Mixed-Integer Programming formulations commonly used for TSP, integration with programming languages like Python, and parallel computing capabilities, enabling faster solution times for complex TSP instances.



\section{Integer Linear Programming Formulation of TSP}

In order to use CPLEX to solve the TSP we first need to define an integer linear programming (ILP) model for it. \\
Let's denote the graph as $G=(V,E)$, where $V$ represents the set of nodes (vertices) and $E$ represents the set of edges.
Let $n$ be the number of nodes in the graph, and let $c_{ij}$ represent the cost (weight) of traveling from node $i$ to node $j$ in the graph $G$. If there is no direct edge between nodes $i$ and $j$, we can set $c_{ij}$ to a large value to indicate that traveling between these nodes is not allowed. \\
A possbile ILP model can be formulated using the following decision variable
\begin{align*}
	& x_{ij} = 
	\begin{cases}
		1, & \text{if edge } (i,j)\in E \text{ is chosen in the optimal circuit}\\
		0, & \text{otherwise}
	\end{cases}
\end{align*}
Using fact that in a TSP solution each node has degree equal to two we obtain:
\begin{align}
	\text{min} &\sum\limits_{(i,j)\in E} c_{ij} \cdot x_{ij} \tag{1.1}\label{eq:1.1} \\
	&\sum\limits_{\:\;\;j=1\:\;\;}^{n} x_{ij} = 2 \quad \text{for } i = 1,2,\ldots,n \tag{1.2}\label{eq:1.2} \\
	&\sum\limits_{(i,j)\in C} x_{ij} \leq |C| - 1 \quad \forall \; C: C \text{ is a subtour of } G \tag{1.3}\label{eq:1.3}
\end{align}
where equation \eqref{eq:1.1} is the total cost of the circuit, constraints \eqref{eq:1.2} are the degree constraints and \eqref{eq:1.3} are the Subtour Elimination Constraints(SEC). Counting the number of constraints we have $n$ constraints from \eqref{eq:1.2} and an exponential amount from \eqref{eq:1.3}. A number of constraints that big makes in practice the problem much harder to resolve, so a common workaround also used in the following algorithms is to ignore SEC and add only the ones that are violated each time cplex returns a feasible solution.

\section{Initialization of CPLEX}

In order to use CPLEX we must initialize the problem first, that means write the TSP according to CPLEX standards. To do this we start with an empty problem and then proceed to add all necessary elements to represent the ILP formulation described previously.

In order to create the empty problem one must simply call the functions \textbf{CPXopenCPLEX} to initialize CPLEX itself and \textbf{CPXcreateprob} to create the problem itself.
Having created the problem it must be populated with variables(columns) and constratints(rows). Variables $x_{ij}$ are added through the function \textbf{CPXnewcols} either in a sequential way(one at a time) or all at the same time by allocating the needed memory and passing cplex all variables by means of arrays, which can be a tedious process except some cases in which it may be easier that way(for example if the data in the instance is saved in a similar way).
The next step is to add constraints. As discussed before it's more efficient to only add constraints specified by \eqref{eq:1.2} without any SEC constraints \eqref{eq:1.3}. The procedure is very similar to the one to add variables: function \textbf{CPXaddrows} can add multiple constraints(rows) at once or one at a time like \textbf{CPXnewcols} and like \textbf{CPXnewcols} the easier way is the sequential one.
This procedure is sumarized in the algorithm below

\begin{algorithm}[H]
	\TitleOfAlgo{\textbf{CPLEX initialization}}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{Graph $G(V,E)$ fully connected \newline$c_{ij}=$ cost of $edge(i,j) \in |E|$ }
	\Output{Instance initialized in CPLEX}
	\vspace{2mm}
	Create empty CPLEX linear problem $p$\\
	\ForEach{edge $e_{ij} \in E$}{
		Add binary variable $x_{i,j}$ with associated cost $c_{ij}$ to $p$\\
	}
	\ForEach{$v \in \{1, \dots ,|V|\}$}{
        $s_v=\sum\limits_{(i,j) \in E} y_{ij}$ where $y_{ij} = 1 \iff i=v$ or $j=v$; otherwise $y_{i,j} = 0$\\
        Add constraint $s_v \leq 2$ to $p$\\
	}
	\Return{$p$}
\end{algorithm}

\section{CPLEX edge representation}

This section describes how to extract and convert a solution obtained using CPLEX into a more compact way. 
By itself CPLEX returns as solution of the TSP an array with the full set of variables $x_{ij}$ which is a bit tedious to read and to use custom functions on top.
To improve this one can convert the solution to a \textit{successors} array. 

\begin{function}[H]
	\TitleOfAlgo{\textbf{xpos}}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$i$, $j$, $|V|$}
	\Output{position of $edge(i,j)$ in CPLEX notation}
	\vspace{2mm}
	\If{$i = j$}{ Error\; }
	\If{$i > j$}{ $i \Leftrightarrow j$\; }
	\Return{$i * |V| + j - ((i + 1) * (i + 2)) / 2$}
\end{function}