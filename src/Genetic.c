#include "Tsp.h"

#include "pthread.h"
#include "time.h"
#include "unistd.h" // needed to get the _POSIX_MONOTONIC_CLOCK and measure time
#include "stdio.h"

#define _2OPT_PROBABILITY 0 //0.01
#define _3OPT_PROBABILITY 0 //0.01
#define N_PERMUTATIONS(inst) inst->nNodes * 2

#define POPULATION_SIZE(inst) inst->params.geneticParams.populationSize
#define CROSSOVER_AMOUNT(inst) inst->params.geneticParams.crossoverAmount
#define MUTATION_AMOUNT(inst) inst->params.geneticParams.mutationAmount
#define REINTRO_AMOUNT(inst) inst->params.geneticParams.reintroductionAmount

typedef struct
{
    int nodes[4];
} AdiacencyList;

typedef struct
{

    Solution bestSol;
    pthread_mutex_t mutex;

    double timeLimit;

} ThreadSharedData;

typedef struct
{
    ThreadSharedData *thShared;

    Solution *baseAddr; // to keep in order to perform the free op

    Solution *population;
    Solution *crossovers;
    Solution *mutations;
    Solution *newerSols;

    AdiacencyList *adiacencyMatrix;

    int *rejectionProbability;

    unsigned int rndState;

    int iterCount;
} ThreadSpecificData;


static inline ThreadSharedData initThreadSharedData(Instance *inst, double timeLimit);
static inline void destroyThreadSharedData(ThreadSharedData *thShared);
static inline ThreadSpecificData initThreadSpecificData(Instance *inst, ThreadSharedData *thShared, unsigned int rndState);
static inline void destroyThreadSpecificData(ThreadSpecificData *thSpecific);

// Function executed by each thread running Genetic Algorithm
static void * runGenetic(void *arg);
// Generate new solution by doing permutations on the nodes of sol. AVOIDS MOVING ELEMENT @ POSTION [0] & [nNodes]
static inline void permuteSolution(Solution *sol, unsigned int *rndState);
// Generate Crossover using Edge Recombination
static inline void EdgeRecombinationCrossover(Solution *out, Solution *in0, Solution *in1, ThreadSpecificData *thSpecific);
// Build adiacency matrix given solutions s0 and s1.
static inline void buildAdiacencyMatrix(ThreadSpecificData *thSpecific, Solution *s0, Solution *s1);
// Find the next node of the path generated by EdgeRecombination
static inline int getNextNodeEdgeRecomb(ThreadSpecificData *thSpecific, Solution *sol, int lastNodeIndexInPath);
// Removes a node from adiacency matrix keeping all data valid
static inline void removeNodeFromAdiacencyMatrix(ThreadSpecificData *thSpecific, int node);
// Mutate solution by some random means
static inline void mutateSolution(Solution *sol, unsigned int *rndState);
// Compute cost as float and saves it AS FLOAT in the cost of the solution(read by casting pointer to float): fitness function
static inline float fitness(ThreadSpecificData *thSpecific, Solution *sol);
// Checks whether s1 is a duplicate of s0 and return if that is the case (ASSUMES PATH STARTS AND ENDS WITH ELEMENT 0)
static inline bool isSolDuplicate(Solution *s0, Solution *s1);
// "Natural selection" select which solutions will be in the next generation
static inline void naturalSelection(ThreadSpecificData *thSpecific);


Solution GeneticAlgorithm(Instance *inst, double timeLimit)
{
    // time limit management
    struct timespec timeStruct;
    clock_gettime(_POSIX_MONOTONIC_CLOCK, &timeStruct);
    double startTime = cvtTimespec2Double(timeStruct);

    // reset seed if debugging
    #ifdef DEBUG
        srand(inst->params.randomSeed);
    #endif

    ThreadSharedData thShared = initThreadSharedData(inst, startTime + timeLimit);

    ThreadSpecificData thSpecific[MAX_THREADS];
    pthread_t threads[MAX_THREADS];
    for (int i = 0; i < inst->params.nThreads; i++)
    {
        thSpecific[i] = initThreadSpecificData(inst, &thShared, (unsigned int)rand());
        pthread_create(&threads[i], NULL, runGenetic, &thSpecific[i]);
    }

    Solution sol = newSolution(inst);

    int iterCount = 0;
    for (int i = 0; i < inst->params.nThreads; i++)
    {
        pthread_join(threads[i], NULL);
        iterCount += thSpecific[i].iterCount;
    }

    cloneSolution(&thShared.bestSol, &sol);

    for (int i = 0; i < inst->params.nThreads; i++)
        destroyThreadSpecificData(&thSpecific[i]);
    destroyThreadSharedData(&thShared);

    // needed since the cost is a float 32 saved into a 128 bit fixed point
    sol.cost = computeSolutionCost(&sol);
    checkSolution(&sol);

    clock_gettime(_POSIX_MONOTONIC_CLOCK, &timeStruct);
    sol.execTime = cvtTimespec2Double(timeStruct) - startTime;

    LOG(LOG_LVL_NOTICE, "Total number of iterations: %d", iterCount);
    LOG(LOG_LVL_NOTICE, "Iterations-per-second: %lf", (double)iterCount/sol.execTime);

    return sol;
}

static inline ThreadSharedData initThreadSharedData(Instance *inst, double timeLimit)
{
    ThreadSharedData thShared = { .timeLimit=timeLimit, .bestSol=newSolution(inst) };
    *(float*)&thShared.bestSol.cost = INFINITY;
    pthread_mutex_init(&thShared.mutex, NULL);
    return thShared;
}

static inline void destroyThreadSharedData(ThreadSharedData *thShared)
{
    destroySolution(&thShared->bestSol);
    pthread_mutex_destroy(&thShared->mutex);
}

static inline ThreadSpecificData initThreadSpecificData(Instance *inst, ThreadSharedData *thShared, unsigned int rndState)
{
    ThreadSpecificData thSpecific = { .iterCount=0, .thShared=thShared };

    // single malloc = more localization for data = more performance
    int fullSize = POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst);
    int adiacencyMatrixSize = inst->nNodes * sizeof(AdiacencyList);

    thSpecific.baseAddr = malloc(fullSize * (sizeof(Solution) + sizeof(int)) + adiacencyMatrixSize); //  + sizeof(Solution*)
    if (!thSpecific.baseAddr)
        throwError("Genetic-initThreadSpecificData: Failed to allocate memory");
    
    thSpecific.population = thSpecific.baseAddr;
    thSpecific.crossovers = &thSpecific.population[POPULATION_SIZE(inst)];
    thSpecific.mutations = &thSpecific.crossovers[CROSSOVER_AMOUNT(inst)];
    thSpecific.newerSols = &thSpecific.mutations[MUTATION_AMOUNT(inst)];
    thSpecific.adiacencyMatrix = (AdiacencyList*)&thSpecific.newerSols[REINTRO_AMOUNT(inst)];
    thSpecific.rejectionProbability = (int*)&thSpecific.adiacencyMatrix[inst->nNodes];
    
    for (int i = 0; i < fullSize; i++)
        thSpecific.baseAddr[i] = newSolution(inst);
    
    for (int i = 0; i < inst->nNodes; i++)
        for (int j = 0; j < 4; j++)
            thSpecific.adiacencyMatrix[i].nodes[j] = -1;

    return thSpecific;
}

static inline void destroyThreadSpecificData(ThreadSpecificData *thSpecific)
{
    Instance *inst = thSpecific->baseAddr->instance;
    int fullSize = POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst);
    for (int i = 0; i < fullSize; i++)
        destroySolution(&thSpecific->baseAddr[i]);
    free(thSpecific->baseAddr);
    thSpecific->baseAddr = NULL;
    thSpecific->population = thSpecific->crossovers = thSpecific->mutations = NULL;    
}

static void * runGenetic(void *arg)
{
    ThreadSpecificData *thSpecific = (ThreadSpecificData*)arg;
    ThreadSharedData *thShared = thSpecific->thShared;
    Instance *inst = thSpecific->baseAddr->instance;
    int n = inst->nNodes;

    struct timespec timeStruct;
    clock_gettime(_POSIX_MONOTONIC_CLOCK, &timeStruct);
    double currentTime = cvtTimespec2Double(timeStruct);

    // setup all solutions to contain each node in indexPath (needed to spare time when doing permutations)
    for (int i = 0; i < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); i++)
        for (int j = 0; j < n; j++)
            thSpecific->baseAddr[i].indexPath[j] = j;

    // generate first population
    for (int i = 0; i < POPULATION_SIZE(inst); i++)
    {
        thSpecific->population[i].indexPath[n] = 0;
        permuteSolution(&thSpecific->population[i], &thSpecific->rndState);
        *(float*)&thSpecific->population[i].cost = fitness(thSpecific, &thSpecific->population[i]);
    }

    Solution *localBestSol = thSpecific->baseAddr;
    while (currentTime < thSpecific->thShared->timeLimit)
    {
        #ifdef DEBUG
            for (int i = 0; i < POPULATION_SIZE(inst)-1; i++)
                for (int j = i+1; j < POPULATION_SIZE(inst); j++)
                    if (isSolDuplicate(&thSpecific->population[i], &thSpecific->population[j]))
                        throwError("There are duplicates inside population at iteration %d: population[%d] and population[%d]", thSpecific->iterCount, i, j);
        #endif

        // crossover solutions
        for (int i = 0; i < CROSSOVER_AMOUNT(inst); i++)
        {
            int index0 = genRandom(&thSpecific->rndState, 0, POPULATION_SIZE(inst)), index1 = genRandom(&thSpecific->rndState, 0, POPULATION_SIZE(inst));
            while (index0 == index1)
                index1 = genRandom(&thSpecific->rndState, 0, POPULATION_SIZE(inst));

            EdgeRecombinationCrossover(&thSpecific->crossovers[i], &thSpecific->population[index0], &thSpecific->population[index1], thSpecific);

            *(float*)&thSpecific->crossovers[i].cost = fitness(thSpecific, &thSpecific->crossovers[i]);
        }

        // mutate solutions
        for (int i = 0; i < MUTATION_AMOUNT(inst); i++)
        {
            int index = genRandom(&thSpecific->rndState, 0, POPULATION_SIZE(inst));
            
            cloneSolution(&thSpecific->population[index], &thSpecific->mutations[i]);
            mutateSolution(&thSpecific->mutations[i], &thSpecific->rndState);
        }

        // generate new solutions as reintroduction
        for (int i = 0; i < REINTRO_AMOUNT(inst); i++)
        {
            permuteSolution(&thSpecific->newerSols[i], &thSpecific->rndState);
            *(float*)&thSpecific->newerSols[i].cost = fitness(thSpecific, &thSpecific->newerSols[i]);
        }
        
        naturalSelection(thSpecific);
        
        #ifdef DEBUG
            for (int i = 0; i < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); i++)
                if ((*(float*)&thSpecific->population[i].cost < 0) || (*(float*)&thSpecific->population[i].cost == INFINITY))
                    throwError("Cost of Solution[%d] is %f", i, *(float*)&thSpecific->population[i].cost);
            
            for (int i = 0; i < POPULATION_SIZE(inst); i++)
            {
                float recompCost = fitness(thSpecific, &thSpecific->population[i]);
                if (abs(*(int*)&recompCost - *(int*)&thSpecific->population[i].cost) > 7) // allow some tolerance on float approximations
                    throwError("Solution[%d] cost does not match: %f vs recomputed %f", i, *(float*)&thSpecific->population[i].cost, recompCost);
            }
        #endif
        
        for (int i = 0; i < POPULATION_SIZE(inst); i++)
        {
            if (rand_r(&thSpecific->rndState) < (int)(_2OPT_PROBABILITY * RAND_MAX))
            {
                thSpecific->population[i].cost = computeSolutionCost(&thSpecific->population[i]);
                apply2OptBestFix(&thSpecific->population[i]);

                if (rand_r(&thSpecific->rndState) < (int)(_3OPT_PROBABILITY * RAND_MAX))
                    apply3OptBestFix(&thSpecific->population[i]);
                    
                *(float*)&thSpecific->population[i].cost = fitness(thSpecific, &thSpecific->population[i]);
            }
        }

        thSpecific->iterCount++;

        for (int i = 0; i < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); i++)
            if (*(float*)&thSpecific->population[i].cost < *(float*)&localBestSol->cost)
                localBestSol = &thSpecific->population[i];
        if (*(float*)&localBestSol->cost < *(float*)&thShared->bestSol.cost)
        {
            pthread_mutex_lock(&thShared->mutex);
            if (*(float*)&localBestSol->cost < *(float*)&thShared->bestSol.cost)
            {
                cloneSolution(localBestSol, &thShared->bestSol);
                LOG(LOG_LVL_INFO, "Found better solution at iteration %7d with approximate cost: \t%f", thSpecific->iterCount, *(float*)&thShared->bestSol.cost);
            }
            pthread_mutex_unlock(&thShared->mutex);
        }

        clock_gettime(_POSIX_MONOTONIC_CLOCK, &timeStruct);
        currentTime = cvtTimespec2Double(timeStruct);
    }

    return NULL;
}

static inline void permuteSolution(Solution *sol, unsigned int *rndState)
{
    int n = sol->instance->nNodes;
    for (int i = 0; i < N_PERMUTATIONS(sol->instance); i++)
    {
        int index0 = genRandom(rndState,1,n);
        int index1 = genRandom(rndState,1,n);
        while (index0 == index1)
            index1 = genRandom(rndState,1,n);
        
        swapElems(sol->indexPath[index0], sol->indexPath[index1])
    }
}

static inline void EdgeRecombinationCrossover(Solution *out, Solution *in0, Solution *in1, ThreadSpecificData *thSpecific)
{
    int n = out->instance->nNodes;

    buildAdiacencyMatrix(thSpecific, in0, in1);

    for (int i = 0; i < n-1; i++)
    {
        int nodeToAdd = getNextNodeEdgeRecomb(thSpecific, out, i);

        #ifdef DEBUG
            for (int j = 0; j < i+1; j++)
                if (nodeToAdd == out->indexPath[j])
                    throwError("Trying to add a node that is already there");
        #endif

        // find node in last part of solution array to swap it with the one in position i
        int nodeToAddPos;
        for (nodeToAddPos = i+1; nodeToAddPos < n; nodeToAddPos++)
            if (out->indexPath[nodeToAddPos] == nodeToAdd)
                break;

        swapElems(out->indexPath[i+1], out->indexPath[nodeToAddPos])

        removeNodeFromAdiacencyMatrix(thSpecific, out->indexPath[i]);
    }
}

static inline void buildAdiacencyMatrix(ThreadSpecificData *thSpecific, Solution *s0, Solution *s1)
{
    int n = s0->instance->nNodes;

    // reset adiancency matrix
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 4; j++)
            thSpecific->adiacencyMatrix[i].nodes[j] = -1;
    
    // build adiacency matrix ######################### ASSUMES THAT EVERY SOLUTION PATH HAS NODE 0 IN POSITION 0 AND POSTION N
    // from s0
    thSpecific->adiacencyMatrix[0].nodes[0] = s0->indexPath[1];
    thSpecific->adiacencyMatrix[0].nodes[1] = s0->indexPath[n-1];
    for (int i = 1; i < n; i++)
    {
        thSpecific->adiacencyMatrix[s0->indexPath[i]].nodes[0] = s0->indexPath[i-1];
        thSpecific->adiacencyMatrix[s0->indexPath[i]].nodes[1] = s0->indexPath[i+1];
    }

    // now from s1
    thSpecific->adiacencyMatrix[0].nodes[2] = s1->indexPath[1];
    thSpecific->adiacencyMatrix[0].nodes[3] = s1->indexPath[n-1];
    for (int i = 1; i < n; i++)
    {
        thSpecific->adiacencyMatrix[s1->indexPath[i]].nodes[2] = s1->indexPath[i-1];
        thSpecific->adiacencyMatrix[s1->indexPath[i]].nodes[3] = s1->indexPath[i+1];
    }

    #ifdef DEBUG
        for (int node = 0; node < n; node++)
            for (int i = 0; i < 4; i++)
                if (thSpecific->adiacencyMatrix[node].nodes[i] == node)
                    throwError("Adiacency Matrix is not coherent at node %d", node);
    #endif
}

static inline int getNextNodeEdgeRecomb(ThreadSpecificData *thSpecific, Solution *sol, int lastNodeIndexInPath)
{
    int n = thSpecific->baseAddr->instance->nNodes;
    int nodeToAdd = thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[0];
    int j = 1;
    for (; j < 4; j++)
    {
        if (nodeToAdd == -1)
            nodeToAdd = thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[j];
        else
            break;
    }
    

    if (nodeToAdd != -1)
    {
        int leastLinksCount = 0;
        for (int i = 0; i < 4; i++)
            if (thSpecific->adiacencyMatrix[thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[0]].nodes[leastLinksCount] != -1)
                leastLinksCount++;

        for (; j < 4; j++)
        {
            if (thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[j] == -1)
                continue;

            int linksCount = 0;
            for (int i = 0; i < 4; i++)
                if (thSpecific->adiacencyMatrix[thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[j]].nodes[linksCount] != -1)
                    linksCount++;

            if ((linksCount < leastLinksCount) || ((linksCount == leastLinksCount) && (genRandom(&thSpecific->rndState, 0, 2) == 1))) // add some randomness if same number of links
            {
                nodeToAdd = thSpecific->adiacencyMatrix[sol->indexPath[lastNodeIndexInPath]].nodes[j];
                leastLinksCount = linksCount;
            }
        }
    }
    else // chose at random from remaining
        nodeToAdd = sol->indexPath[genRandom(&thSpecific->rndState, lastNodeIndexInPath+1, n)];
    
    return nodeToAdd;
}

static inline void removeNodeFromAdiacencyMatrix(ThreadSpecificData *thSpecific, int node)
{
    for (int j = 0; j < 4; j++) // need to check every neighboring node
    {
        if (thSpecific->adiacencyMatrix[node].nodes[j] == -1)
            continue;

        int l;
        for (l = 0; l < 4; l++)
            if (thSpecific->adiacencyMatrix[thSpecific->adiacencyMatrix[node].nodes[j]].nodes[l] == node)
                break;

        thSpecific->adiacencyMatrix[thSpecific->adiacencyMatrix[node].nodes[j]].nodes[l] = -1;

        thSpecific->adiacencyMatrix[node].nodes[j] = -1;
    }
}

static inline void mutateSolution(Solution *sol, unsigned int *rndState)
{
    Instance *inst = sol->instance;
    int n = inst->nNodes;
    int *path = sol->indexPath;

    switch (genRandom(rndState, 0, 1))
    {
    case 0: // swap two edges (same as performing random 2opt move)
    {
        int edge0 = genRandom(rndState, 1, n), edge1 = genRandom(rndState, 1, n);
        while (abs(edge0 - edge1) < 2)
            edge1 = genRandom(rndState, 1, n);

        if (edge0 > edge1)
            swapElems(edge0, edge1)

        // update cost
        #if ((COMPUTATION_TYPE == COMPUTE_OPTION_AVX) || (COMPUTATION_TYPE == COMPUTE_OPTION_BASE))
            *(float*)&sol->cost -= computeEdgeCost(inst->X[path[edge0]], inst->Y[path[edge0]], inst->X[path[edge0+1]], inst->Y[path[edge0+1]], inst);
            *(float*)&sol->cost -= computeEdgeCost(inst->X[path[edge1]], inst->Y[path[edge1]], inst->X[path[edge1+1]], inst->Y[path[edge1+1]], inst);
            *(float*)&sol->cost += computeEdgeCost(inst->X[path[edge0]], inst->Y[path[edge0]], inst->X[path[edge1]], inst->Y[path[edge1]], inst);
            *(float*)&sol->cost += computeEdgeCost(inst->X[path[edge0+1]], inst->Y[path[edge0+1]], inst->X[path[edge1+1]], inst->Y[path[edge1+1]], inst);
        #elif (COMPUTATION_TYPE == COMPUTE_OPTION_USE_COST_MATRIX)
            *(float*)&sol->cost -= inst->edgeCostMat[(size_t)path[edge0] * (size_t)inst->nNodes + (size_t)path[edge0+1]];
            *(float*)&sol->cost -= inst->edgeCostMat[(size_t)path[edge1] * (size_t)inst->nNodes + (size_t)path[edge1+1]];
            *(float*)&sol->cost += inst->edgeCostMat[(size_t)path[edge0] * (size_t)inst->nNodes + (size_t)path[edge1]];
            *(float*)&sol->cost += inst->edgeCostMat[(size_t)path[edge0+1] * (size_t)inst->nNodes + (size_t)path[edge1+1]];
        #endif

        for (int smallI = edge0 + 1, bigI = edge1; smallI < bigI; smallI++, bigI--)
            swapElems(path[smallI], path[bigI])

        break;
    }
    
    case 1: // swap two nodes (same as vns kick)
    {
        int edges[2] = { genRandom(rndState, 1, n), genRandom(rndState, 1, n) };
        while (edges[0] == edges[1])
            edges[1] = genRandom(rndState, 1, n);
        
        int first = path[edges[0]];

        for (int i = 0; i < sizeof(edges) / sizeof(edges[0]); i++)
        {
            // subtract old cost
            #if ((COMPUTATION_TYPE == COMPUTE_OPTION_AVX) || (COMPUTATION_TYPE == COMPUTE_OPTION_BASE))
                *(float*)&sol->cost -= computeEdgeCost(inst->X[path[edges[i]-1]], inst->Y[path[edges[i]-1]], inst->X[path[edges[i]]],   inst->Y[path[edges[i]]],   inst);
                *(float*)&sol->cost -= computeEdgeCost(inst->X[path[edges[i]]],   inst->Y[path[edges[i]]],   inst->X[path[edges[i]+1]], inst->Y[path[edges[i]+1]], inst);
            #elif (COMPUTATION_TYPE == COMPUTE_OPTION_USE_COST_MATRIX)
                *(float*)&sol->cost -= inst->edgeCostMat[(size_t)path[edges[i]] * (size_t)n + (size_t)path[edges[i]-1]];
                *(float*)&sol->cost -= inst->edgeCostMat[(size_t)path[edges[i]] * (size_t)n + (size_t)path[edges[i]+1]];
            #endif

            
            if (i == 0)
                path[edges[i]] = path[edges[i+1]];
            else
                path[edges[i]] = first;

            // add new cost
            #if ((COMPUTATION_TYPE == COMPUTE_OPTION_AVX) || (COMPUTATION_TYPE == COMPUTE_OPTION_BASE))
                *(float*)&sol->cost += computeEdgeCost(inst->X[path[edges[i]-1]], inst->Y[path[edges[i]-1]], inst->X[path[edges[i]]],   inst->Y[path[edges[i]]],   inst);
                *(float*)&sol->cost += computeEdgeCost(inst->X[path[edges[i]]],   inst->Y[path[edges[i]]],   inst->X[path[edges[i]+1]], inst->Y[path[edges[i]+1]], inst);
            #elif (COMPUTATION_TYPE == COMPUTE_OPTION_USE_COST_MATRIX)
                *(float*)&sol->cost += inst->edgeCostMat[(size_t)path[edges[i]] * (size_t)n + (size_t)path[edges[i]-1]];
                *(float*)&sol->cost += inst->edgeCostMat[(size_t)path[edges[i]] * (size_t)n + (size_t)path[edges[i]+1]];
            #endif
        }
        break;
    }

    default:
        break;
    }
}

#if (COMPUTATION_TYPE == COMPUTE_OPTION_AVX)
static inline float fitness(ThreadSpecificData *thSpecific, Solution *sol)
{
    Instance *inst = sol->instance;

    __m256 costSumVec = _mm256_setzero_ps();
    __m256i permuteVec = _mm256_setr_epi32(1,2,3,4,5,6,7,7);
    for (int i = 0; i < inst->nNodes - (AVX_VEC_SIZE-2); i+=(AVX_VEC_SIZE-1))
    {
        __m256i index = _mm256_loadu_si256((__m256i_u*)&sol->indexPath[i]);
        __m256 x1 = _mm256_i32gather_ps(inst->X, index, 4), y1 = _mm256_i32gather_ps(inst->Y, index, 4);
        __m256 x2 = _mm256_permutevar8x32_ps(x1, permuteVec), y2 = _mm256_permutevar8x32_ps(y1, permuteVec);
        __m256 cost = computeEdgeCost_VEC(x1, y1, x2, y2, inst);
        costSumVec = _mm256_add_ps(costSumVec, cost);
    }
    
    float avxStore[AVX_VEC_SIZE];
    float cost = 0;
    _mm256_storeu_ps(avxStore, costSumVec);
    for (int i = 0; i < AVX_VEC_SIZE-1; i++)
        cost += avxStore[i];
    
    if (inst->nNodes - (inst->nNodes % (AVX_VEC_SIZE-1)) > 0)
        for (int i = inst->nNodes - (inst->nNodes % (AVX_VEC_SIZE-1)); i < inst->nNodes; i++)
            cost += computeEdgeCost(inst->X[sol->indexPath[i]], inst->Y[sol->indexPath[i]], inst->X[sol->indexPath[i+1]], inst->Y[sol->indexPath[i+1]], inst);

    return cost;
}
#elif ((COMPUTATION_TYPE == COMPUTE_OPTION_BASE) || (COMPUTATION_TYPE == COMPUTE_OPTION_USE_COST_MATRIX))
static inline float fitness(ThreadSpecificData *thSpecific, Solution *sol)
{
    Instance *inst = sol->instance;

    float cost = 0.F;
    for (int i = 0; i < inst->nNodes; i++)
        #if (COMPUTATION_TYPE == COMPUTE_OPTION_BASE)
            cost += computeEdgeCost(inst->X[sol->indexPath[i]], inst->Y[sol->indexPath[i]], inst->X[sol->indexPath[i+1]], inst->Y[sol->indexPath[i+1]], inst);
        #elif (COMPUTATION_TYPE == COMPUTE_OPTION_USE_COST_MATRIX)
            cost += inst->edgeCostMat[sol->indexPath[i] * inst->nNodes + sol->indexPath[i+1]];
        #endif

    return cost;
}
#endif

static inline bool isSolDuplicate(Solution *s0, Solution *s1)
{
    // check if costs are very similar using int casting exploit explained here https://staff.polito.it/claudio.fornaro/CorsoINF/Other%20interesting%20lectures/Comparing%20Floating%20Point%20Numbers.pdf
    if ((*(float*)&s0->cost) != (*(float*)&s1->cost))//(abs(*(int*)&s0->cost - *(int*)&s1->cost) > 15); // if costs are not similar than the solutions do not have a chance of being duplicates
        return false;

    int n = s0->instance->nNodes;

    int j = 1;
    if (s0->indexPath[1] != s1->indexPath[j])
        j = n-1;
    if (s0->indexPath[1] != s1->indexPath[j]) // first edge of s0 is not in s1
        return false;

    if (j == 1)
    {
        for (int i = 1; i < n; i++, j++)
            if (s0->indexPath[i] != s1->indexPath[j])
                return false;
    }
    else
    {
        for (int i = 1; i < n; i++, j--)
            if (s0->indexPath[i] != s1->indexPath[j])
                return false;
    }
    
    return true;
}

static inline void naturalSelection(ThreadSpecificData *thSpecific)
{
    Instance *inst = thSpecific->thShared->bestSol.instance;

    float min = INFINITY, max = 0;
    for (int i = 0; i < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); i++)
    {
        if (min > *(float*)&thSpecific->population[i].cost)
            min = *(float*)&thSpecific->population[i].cost;
        if (max < *(float*)&thSpecific->population[i].cost)
            max = *(float*)&thSpecific->population[i].cost;
    }
    

    // compute acceptance probability
    for (int i = 0; i < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); i++)
    {
        float fpRejectionProb = (*(float*)&thSpecific->population[i].cost - min) / (max - min);

        thSpecific->rejectionProbability[i] = (int)(fpRejectionProb * RAND_MAX);

        for (int k = 0; k < i; k++)
            if (isSolDuplicate(&thSpecific->population[k], &thSpecific->population[i]))
                thSpecific->rejectionProbability[i] = RAND_MAX;
    }

    for (int i = 0; i < POPULATION_SIZE(inst); i++)
    {
        for (int j = i+1; j < POPULATION_SIZE(inst) + CROSSOVER_AMOUNT(inst) + MUTATION_AMOUNT(inst) + REINTRO_AMOUNT(inst); j++)
        {
            if ((thSpecific->rejectionProbability[j] == RAND_MAX) || (rand_r(&thSpecific->rndState) < thSpecific->rejectionProbability[j]))
                continue;
            
            swapElems(thSpecific->population[i], thSpecific->population[j])
            swapElems(thSpecific->rejectionProbability[i], thSpecific->rejectionProbability[j])
        }
    }
}